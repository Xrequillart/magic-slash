#!/bin/bash
# Magic Slash CLI
# Manage your Magic Slash configuration

# Config file path
CONFIG_FILE="$HOME/.config/magic-slash/config.json"
WEB_UI_DIR="$HOME/.local/share/magic-slash/web-ui"

# Read version from config file (set during installation)
if [ -f "$CONFIG_FILE" ]; then
  VERSION=$(jq -r '.version // "unknown"' "$CONFIG_FILE" 2>/dev/null)
else
  VERSION="unknown"
fi

# Check for --help or -h flag
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
  echo ""
  echo "Magic Slash v$VERSION"
  echo ""
  echo "Usage:"
  echo "  magic-slash          Open web UI configuration (localhost:3847)"
  echo "  magic-slash --cli    Open interactive terminal configuration"
  echo "  magic-slash --help   Show this help message"
  echo ""
  exit 0
fi

# Check for --cli or --tui flag (terminal mode)
if [ "$1" = "--cli" ] || [ "$1" = "--tui" ]; then
  shift  # Remove the flag from arguments
  # Continue to terminal UI below
else
  # Default: launch web UI
  if [ -d "$WEB_UI_DIR" ]; then
    cd "$WEB_UI_DIR" || exit 1

    # Check if node_modules exists
    if [ ! -d "node_modules" ]; then
      echo "Installing web UI dependencies..."
      npm install --silent
    fi

    # Start the server
    node server.js
    exit 0
  else
    echo "Error: Web UI not found at $WEB_UI_DIR"
    echo "Falling back to terminal UI..."
    echo ""
  fi
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color
PURPLE='\033[0;35m'

# Menu state
SELECTED=0
declare -a REPO_NAMES
declare -a REPO_PATHS
declare -a MENU_OPTIONS

# Language submenu state
LANG_SUBMENU_SELECTED=0
declare -a LANG_MENU_OPTIONS

# Hide cursor
hide_cursor() {
  printf '\033[?25l'
}

# Show cursor
show_cursor() {
  printf '\033[?25h'
}

# Clean exit
cleanup() {
  show_cursor
  echo ""
  exit 0
}

trap cleanup EXIT INT TERM

# Print logo
print_logo() {
  echo ""
  echo -e "   ${BOLD}                    _        ${NC}"
  echo -e "   ${BOLD} _ __ ___   __ _  __ _(_) ___  ${NC}"
  echo -e "   ${BOLD}| '_ \` _ \\ / _\` |/ _\` | |/ __| ${NC}"
  echo -e "   ${BOLD}| | | | | | (_| | (_| | | (__  ${NC}"
  echo -e "   ${BOLD}|_| |_| |_|\\__,_|\\__, |_|\\___| ${NC}"
  echo -e "   ${PURPLE}    __${NC}${BOLD}           |___/      ${NC}"
  echo -e "   ${PURPLE}   / /${NC}${BOLD}__| | __ _ ___| |__   ${NC}"
  echo -e "   ${PURPLE}  / /${NC}${BOLD}/ __| |/ _\` / __| '_ \\  ${NC}"
  echo -e "   ${PURPLE} / /${NC}${BOLD}\\__ \\ | (_| \\__ \\ | | | ${NC}"
  echo -e "   ${PURPLE}/_/ ${NC}${BOLD}|___/_|\\__,_|___/_| |_| ${NC}"
  echo ""
}

# Read configuration and populate arrays
read_config() {
  REPO_NAMES=()
  REPO_PATHS=()

  if [ -f "$CONFIG_FILE" ]; then
    while IFS= read -r name; do
      REPO_NAMES+=("$name")
      path=$(jq -r ".repositories[\"$name\"].path" "$CONFIG_FILE")
      REPO_PATHS+=("$path")
    done < <(jq -r '.repositories | keys[]' "$CONFIG_FILE")
  fi
}

# Get language setting from config
get_language_setting() {
  local key="$1"
  local default="$2"
  if [ -f "$CONFIG_FILE" ]; then
    local value
    value=$(jq -r ".languages.$key // \"\"" "$CONFIG_FILE" 2>/dev/null)
    if [ -n "$value" ] && [ "$value" != "null" ]; then
      echo "$value"
      return
    fi
  fi
  echo "$default"
}

# Convert language code to display name
get_language_display_name() {
  local code="$1"
  case "$code" in
    en) echo "English" ;;
    fr) echo "Français" ;;
    *) echo "$code" ;;
  esac
}

# Build menu options dynamically
build_menu_options() {
  MENU_OPTIONS=()

  # Add edit options for each repo
  for name in "${REPO_NAMES[@]}"; do
    MENU_OPTIONS+=("Edit $name")
  done

  # Add management options
  MENU_OPTIONS+=("Add new repository")
  if [ ${#REPO_NAMES[@]} -gt 0 ]; then
    MENU_OPTIONS+=("Remove repository")
  fi
  MENU_OPTIONS+=("Language settings")
  MENU_OPTIONS+=("Quit")
}

# Display header
display_header() {
  clear
  print_logo
  echo -e "${BOLD}  Magic Slash v${VERSION}${NC}"
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo -e "${DIM}Configured repositories:${NC}"

  if [ ${#REPO_NAMES[@]} -eq 0 ]; then
    echo -e "  ${DIM}(none)${NC}"
  else
    for i in "${!REPO_NAMES[@]}"; do
      local name="${REPO_NAMES[$i]}"
      local path="${REPO_PATHS[$i]}"
      local keywords=""

      # Get keywords
      if [ -f "$CONFIG_FILE" ]; then
        keywords=$(jq -r ".repositories[\"$name\"].keywords // [] | join(\", \")" "$CONFIG_FILE" 2>/dev/null)
      fi

      echo -e "  ${BOLD}$name${NC}: ${CYAN}$path${NC}"
      if [ -n "$keywords" ]; then
        echo -e "    ${DIM}keywords: $keywords${NC}"
      fi
    done
  fi

  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo -e "${DIM}Use ↑/↓ to navigate, Enter to select${NC}"
  echo ""
}

# Display menu
display_menu() {
  for i in "${!MENU_OPTIONS[@]}"; do
    if [ $i -eq $SELECTED ]; then
      echo -e "  ${GREEN}→ ${BOLD}${MENU_OPTIONS[$i]}${NC}"
    else
      echo -e "    ${DIM}${MENU_OPTIONS[$i]}${NC}"
    fi
  done
}

# Update configuration (create or update config file)
save_config() {
  mkdir -p "$(dirname "$CONFIG_FILE")"

  # Build repositories JSON
  local repos_json="{}"
  for i in "${!REPO_NAMES[@]}"; do
    local name="${REPO_NAMES[$i]}"
    local path="${REPO_PATHS[$i]}"

    # Get existing keywords or default to repo name
    local keywords_json="[\"$name\"]"
    if [ -f "$CONFIG_FILE" ]; then
      local existing
      existing=$(jq -r ".repositories[\"$name\"].keywords // null" "$CONFIG_FILE" 2>/dev/null)
      if [ "$existing" != "null" ]; then
        keywords_json=$(jq -c ".repositories[\"$name\"].keywords" "$CONFIG_FILE")
      fi
    fi

    repos_json=$(echo "$repos_json" | jq --arg name "$name" --arg path "$path" --argjson keywords "$keywords_json" \
      '.[$name] = {"path": $path, "keywords": $keywords}')
  done

  # Preserve existing language settings
  local languages_json="{}"
  if [ -f "$CONFIG_FILE" ]; then
    languages_json=$(jq -c '.languages // {}' "$CONFIG_FILE" 2>/dev/null)
    if [ -z "$languages_json" ] || [ "$languages_json" = "null" ]; then
      languages_json="{}"
    fi
  fi

  # Write config file
  jq -n --arg version "$VERSION" --argjson repos "$repos_json" --argjson languages "$languages_json" \
    '{"version": $version, "repositories": $repos, "languages": $languages}' > "$CONFIG_FILE"
}

# Add a new repository
add_repository() {
  show_cursor
  echo ""
  echo -e "  ${BOLD}Add new repository${NC}"
  echo ""

  read -p "  Name (e.g.: api, web, mobile): " new_name < /dev/tty

  if [ -z "$new_name" ]; then
    echo -e "  ${DIM}Cancelled${NC}"
    sleep 1
    return
  fi

  # Validate name
  if ! [[ "$new_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo -e "  ${RED}Invalid name. Use only letters, numbers, hyphens and underscores.${NC}"
    sleep 2
    return
  fi

  # Check if name already exists
  for name in "${REPO_NAMES[@]}"; do
    if [ "$name" = "$new_name" ]; then
      echo -e "  ${RED}A repository named '$new_name' already exists.${NC}"
      sleep 2
      return
    fi
  done

  read -p "  Path (e.g.: ~/projects/my-$new_name): " new_path < /dev/tty

  if [ -z "$new_path" ]; then
    echo -e "  ${DIM}Cancelled${NC}"
    sleep 1
    return
  fi

  # Expand ~
  new_path="${new_path/#\~/$HOME}"

  # Validate path
  if [ ! -d "$new_path" ]; then
    echo -e "  ${YELLOW}⚠️  Directory does not exist: $new_path${NC}"
    read -p "  Continue anyway? (y/N) " confirm < /dev/tty
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo -e "  ${DIM}Cancelled${NC}"
      sleep 1
      return
    fi
  elif [ ! -d "$new_path/.git" ]; then
    echo -e "  ${YELLOW}⚠️  $new_path is not a git repository${NC}"
    read -p "  Continue anyway? (y/N) " confirm < /dev/tty
    if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
      echo -e "  ${DIM}Cancelled${NC}"
      sleep 1
      return
    fi
  fi

  read -p "  Keywords for auto-detection (comma-separated, optional): " keywords_input < /dev/tty

  # Add to arrays
  REPO_NAMES+=("$new_name")
  REPO_PATHS+=("$new_path")

  # Prepare keywords JSON
  local keywords_json
  if [ -z "$keywords_input" ]; then
    keywords_json="[\"$new_name\"]"
  else
    keywords_json=$(echo "$keywords_input" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R . | jq -s .)
  fi

  # Save to config with keywords
  mkdir -p "$(dirname "$CONFIG_FILE")"

  if [ ! -f "$CONFIG_FILE" ]; then
    echo '{"version": "'"$VERSION"'", "repositories": {}}' > "$CONFIG_FILE"
  fi

  local tmp_file
  tmp_file=$(mktemp)
  jq --arg name "$new_name" --arg path "$new_path" --argjson keywords "$keywords_json" \
    '.repositories[$name] = {"path": $path, "keywords": $keywords}' "$CONFIG_FILE" > "$tmp_file" && mv "$tmp_file" "$CONFIG_FILE"

  echo -e "  ${GREEN}✅ Repository '$new_name' added${NC}"
  sleep 1

  # Rebuild menu
  build_menu_options
  SELECTED=0
}

# Remove a repository
remove_repository() {
  if [ ${#REPO_NAMES[@]} -eq 0 ]; then
    echo -e "  ${DIM}No repositories to remove${NC}"
    sleep 1
    return
  fi

  show_cursor
  echo ""
  echo -e "  ${BOLD}Remove repository${NC}"
  echo ""
  echo "  Select repository to remove:"
  echo ""

  for i in "${!REPO_NAMES[@]}"; do
    echo -e "  $((i+1)). ${REPO_NAMES[$i]} (${REPO_PATHS[$i]})"
  done
  echo -e "  0. Cancel"
  echo ""

  read -p "  Choice: " choice < /dev/tty

  if [ "$choice" = "0" ] || [ -z "$choice" ]; then
    echo -e "  ${DIM}Cancelled${NC}"
    sleep 1
    return
  fi

  # Validate choice
  if ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -lt 1 ] || [ "$choice" -gt ${#REPO_NAMES[@]} ]; then
    echo -e "  ${RED}Invalid choice${NC}"
    sleep 1
    return
  fi

  local index=$((choice - 1))
  local name_to_remove="${REPO_NAMES[$index]}"

  echo ""
  read -p "  Are you sure you want to remove '$name_to_remove'? (y/N) " confirm < /dev/tty

  if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
    echo -e "  ${DIM}Cancelled${NC}"
    sleep 1
    return
  fi

  # Remove from config file
  local tmp_file
  tmp_file=$(mktemp)
  jq --arg name "$name_to_remove" 'del(.repositories[$name])' "$CONFIG_FILE" > "$tmp_file" && mv "$tmp_file" "$CONFIG_FILE"

  echo -e "  ${GREEN}✅ Repository '$name_to_remove' removed${NC}"
  sleep 1

  # Reload config and rebuild menu
  read_config
  build_menu_options
  SELECTED=0
}

# Edit repository (path and keywords)
edit_repository() {
  local index=$1
  local name="${REPO_NAMES[$index]}"
  local current_path="${REPO_PATHS[$index]}"

  show_cursor
  echo ""
  echo -e "  ${BOLD}Edit $name${NC}"
  echo ""
  echo -e "  Current path: ${CYAN}$current_path${NC}"

  # Get current keywords
  local current_keywords=""
  if [ -f "$CONFIG_FILE" ]; then
    current_keywords=$(jq -r ".repositories[\"$name\"].keywords // [] | join(\", \")" "$CONFIG_FILE" 2>/dev/null)
  fi
  echo -e "  Current keywords: ${CYAN}${current_keywords:-$name}${NC}"
  echo ""

  read -p "  New path (empty to keep current): " new_path < /dev/tty

  if [ -n "$new_path" ]; then
    # Expand ~
    new_path="${new_path/#\~/$HOME}"

    # Validate
    if [ ! -d "$new_path" ]; then
      echo -e "  ${YELLOW}⚠️  Directory does not exist: $new_path${NC}"
      read -p "  Continue anyway? (y/N) " confirm < /dev/tty
      if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        new_path="$current_path"
      fi
    elif [ ! -d "$new_path/.git" ]; then
      echo -e "  ${YELLOW}⚠️  $new_path is not a git repository${NC}"
      read -p "  Continue anyway? (y/N) " confirm < /dev/tty
      if [ "$confirm" != "y" ] && [ "$confirm" != "Y" ]; then
        new_path="$current_path"
      fi
    fi
  else
    new_path="$current_path"
  fi

  read -p "  New keywords (empty to keep current): " new_keywords < /dev/tty

  # Prepare keywords JSON
  local keywords_json
  if [ -n "$new_keywords" ]; then
    keywords_json=$(echo "$new_keywords" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R . | jq -s .)
  else
    # Keep existing keywords
    keywords_json=$(jq -c ".repositories[\"$name\"].keywords // [\"$name\"]" "$CONFIG_FILE")
  fi

  # Update config
  local tmp_file
  tmp_file=$(mktemp)
  jq --arg name "$name" --arg path "$new_path" --argjson keywords "$keywords_json" \
    '.repositories[$name].path = $path | .repositories[$name].keywords = $keywords' "$CONFIG_FILE" > "$tmp_file" && mv "$tmp_file" "$CONFIG_FILE"

  # Update local array
  REPO_PATHS[$index]="$new_path"

  echo -e "  ${GREEN}✅ Repository '$name' updated${NC}"
  sleep 1
}

# Build language menu options with current values
build_language_menu_options() {
  LANG_MENU_OPTIONS=()

  local commit_lang pr_lang jira_lang discussion_lang
  commit_lang=$(get_language_setting "commit" "en")
  pr_lang=$(get_language_setting "pullRequest" "en")
  jira_lang=$(get_language_setting "jiraComment" "en")
  discussion_lang=$(get_language_setting "discussion" "en")

  LANG_MENU_OPTIONS+=("Commit language ($(get_language_display_name "$commit_lang"))")
  LANG_MENU_OPTIONS+=("Pull Request language ($(get_language_display_name "$pr_lang"))")
  LANG_MENU_OPTIONS+=("Jira comment language ($(get_language_display_name "$jira_lang"))")
  LANG_MENU_OPTIONS+=("Discussion language ($(get_language_display_name "$discussion_lang"))")
  LANG_MENU_OPTIONS+=("Back")
}

# Display language submenu header
display_language_header() {
  clear
  print_logo
  echo -e "${BOLD}  Language Settings${NC}"
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo -e "${DIM}Configure the language for each feature:${NC}"
  echo ""
  echo -e "  ${DIM}• Commit: Language for commit messages${NC}"
  echo -e "  ${DIM}• Pull Request: Language for PR title/description${NC}"
  echo -e "  ${DIM}• Jira comment: Language for Jira comments${NC}"
  echo -e "  ${DIM}• Discussion: Language for Claude Code interactions${NC}"
  echo ""
  echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
  echo ""
  echo -e "${DIM}Use ↑/↓ to navigate, Enter to select${NC}"
  echo ""
}

# Display language menu
display_language_menu() {
  for i in "${!LANG_MENU_OPTIONS[@]}"; do
    if [ $i -eq $LANG_SUBMENU_SELECTED ]; then
      echo -e "  ${GREEN}→ ${BOLD}${LANG_MENU_OPTIONS[$i]}${NC}"
    else
      echo -e "    ${DIM}${LANG_MENU_OPTIONS[$i]}${NC}"
    fi
  done
}

# Handle language menu input
handle_language_input() {
  local key

  read -rsn1 key

  if [[ $key == $'\x1b' ]]; then
    read -rsn2 key
    case $key in
      '[A') # Up arrow
        ((LANG_SUBMENU_SELECTED--))
        [ $LANG_SUBMENU_SELECTED -lt 0 ] && LANG_SUBMENU_SELECTED=$((${#LANG_MENU_OPTIONS[@]} - 1))
        ;;
      '[B') # Down arrow
        ((LANG_SUBMENU_SELECTED++))
        [ $LANG_SUBMENU_SELECTED -ge ${#LANG_MENU_OPTIONS[@]} ] && LANG_SUBMENU_SELECTED=0
        ;;
    esac
  elif [[ $key == '' ]]; then # Enter key
    return 1
  elif [[ $key == 'q' ]] || [[ $key == 'Q' ]]; then
    LANG_SUBMENU_SELECTED=$((${#LANG_MENU_OPTIONS[@]} - 1)) # Select "Back"
    return 1
  fi

  return 0
}

# Interactive language selection
select_language() {
  local current="$1"
  local lang_selected=0
  local lang_options=("English" "Français")

  # Set initial selection based on current value
  if [ "$current" = "fr" ]; then
    lang_selected=1
  fi

  while true; do
    # Redraw selection - output to /dev/tty to avoid capture by subshell
    # Use printf to avoid extra newline from echo
    printf '\033[2A\033[J' > /dev/tty  # Move up 2 lines and clear
    for i in "${!lang_options[@]}"; do
      if [ $i -eq $lang_selected ]; then
        printf "    ${GREEN}→ ${BOLD}%s${NC}\n" "${lang_options[$i]}" > /dev/tty
      else
        printf "      ${DIM}%s${NC}\n" "${lang_options[$i]}" > /dev/tty
      fi
    done

    local key
    read -rsn1 key < /dev/tty

    if [[ $key == $'\x1b' ]]; then
      read -rsn2 key < /dev/tty
      case $key in
        '[A') # Up
          ((lang_selected--))
          [ $lang_selected -lt 0 ] && lang_selected=$((${#lang_options[@]} - 1))
          ;;
        '[B') # Down
          ((lang_selected++))
          [ $lang_selected -ge ${#lang_options[@]} ] && lang_selected=0
          ;;
      esac
    elif [[ $key == '' ]]; then # Enter
      if [ $lang_selected -eq 0 ]; then
        echo "en"
      else
        echo "fr"
      fi
      return
    elif [[ $key == 'q' ]] || [[ $key == 'Q' ]]; then
      echo "$current"  # Return current value (cancelled)
      return
    fi
  done
}

# Save a language setting
save_language_setting() {
  local key="$1"
  local value="$2"

  mkdir -p "$(dirname "$CONFIG_FILE")"

  if [ ! -f "$CONFIG_FILE" ]; then
    echo '{"version": "'"$VERSION"'", "repositories": {}, "languages": {}}' > "$CONFIG_FILE"
  fi

  local tmp_file
  tmp_file=$(mktemp)
  jq --arg key "$key" --arg value "$value" \
    '.languages[$key] = $value' "$CONFIG_FILE" > "$tmp_file" && mv "$tmp_file" "$CONFIG_FILE"
}

# Change a language setting
change_language_setting() {
  local setting_key="$1"
  local setting_name="$2"
  local default_value="$3"

  local current
  current=$(get_language_setting "$setting_key" "$default_value")

  show_cursor
  echo ""
  echo -e "  ${BOLD}$setting_name${NC}"
  echo ""
  echo -e "  ${DIM}Current: $(get_language_display_name "$current")${NC}"
  echo ""
  echo "  Select new language:"
  echo ""  # Placeholder line 1 (English)
  echo ""  # Placeholder line 2 (Français)

  hide_cursor
  local new_value
  new_value=$(select_language "$current")

  if [ "$new_value" != "$current" ]; then
    save_language_setting "$setting_key" "$new_value"
    show_cursor
    echo ""
    echo -e "  ${GREEN}✅ $setting_name set to $(get_language_display_name "$new_value")${NC}"
    sleep 1
  fi
}

# Language settings submenu loop
language_settings_menu() {
  LANG_SUBMENU_SELECTED=0
  build_language_menu_options

  while true; do
    display_language_header
    display_language_menu

    if ! handle_language_input; then
      local option="${LANG_MENU_OPTIONS[$LANG_SUBMENU_SELECTED]}"

      if [[ "$option" == Commit\ language* ]]; then
        change_language_setting "commit" "Commit language" "en"
        build_language_menu_options
        hide_cursor
      elif [[ "$option" == Pull\ Request\ language* ]]; then
        change_language_setting "pullRequest" "Pull Request language" "en"
        build_language_menu_options
        hide_cursor
      elif [[ "$option" == Jira\ comment\ language* ]]; then
        change_language_setting "jiraComment" "Jira comment language" "en"
        build_language_menu_options
        hide_cursor
      elif [[ "$option" == Discussion\ language* ]]; then
        change_language_setting "discussion" "Discussion language" "en"
        build_language_menu_options
        hide_cursor
      elif [ "$option" = "Back" ]; then
        break
      fi
    fi
  done
}

# Handle key press
handle_input() {
  local key

  # Read first character
  read -rsn1 key

  # Check for escape sequence (arrow keys)
  if [[ $key == $'\x1b' ]]; then
    read -rsn2 key
    case $key in
      '[A') # Up arrow
        ((SELECTED--))
        [ $SELECTED -lt 0 ] && SELECTED=$((${#MENU_OPTIONS[@]} - 1))
        ;;
      '[B') # Down arrow
        ((SELECTED++))
        [ $SELECTED -ge ${#MENU_OPTIONS[@]} ] && SELECTED=0
        ;;
    esac
  elif [[ $key == '' ]]; then # Enter key
    return 1 # Signal selection made
  elif [[ $key == 'q' ]] || [[ $key == 'Q' ]]; then
    SELECTED=$((${#MENU_OPTIONS[@]} - 1)) # Select "Quit"
    return 1
  fi

  return 0
}

# Main menu loop
main_menu() {
  hide_cursor

  while true; do
    display_header
    display_menu

    if ! handle_input; then
      local option="${MENU_OPTIONS[$SELECTED]}"

      # Check if it's an "Edit X" option
      if [[ "$option" == Edit\ * ]]; then
        local repo_name="${option#Edit }"
        # Find index of this repo
        for i in "${!REPO_NAMES[@]}"; do
          if [ "${REPO_NAMES[$i]}" = "$repo_name" ]; then
            edit_repository "$i"
            read_config
            build_menu_options
            break
          fi
        done
        hide_cursor
      elif [ "$option" = "Add new repository" ]; then
        add_repository
        hide_cursor
      elif [ "$option" = "Remove repository" ]; then
        remove_repository
        hide_cursor
      elif [ "$option" = "Language settings" ]; then
        language_settings_menu
        hide_cursor
      elif [ "$option" = "Quit" ]; then
        break
      fi

      # Reset selection if it's now out of bounds
      if [ $SELECTED -ge ${#MENU_OPTIONS[@]} ]; then
        SELECTED=$((${#MENU_OPTIONS[@]} - 1))
      fi
    fi
  done
}

# Check for jq
if ! command -v jq &> /dev/null; then
  echo -e "${RED}❌ jq is required but not installed.${NC}"
  echo "   Install it with: brew install jq (macOS) / apt install jq (Linux)"
  exit 1
fi

# Main
read_config
build_menu_options
main_menu
echo ""
echo -e "${GREEN}Goodbye!${NC}"
echo ""
